# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_strategies.ipynb.

# %% auto 0
__all__ = ['base_path', 'processed_data_dir', 'csv_path', 'df500', 'check_directional_crossover', 'get_symbol_data',
           'check_close_under_falling_20', 'check_close_above_20', 'check_20_200_breakout', 'check_single_candle_span',
           'check_historical_minmax']

# %% ../nbs/02_strategies.ipynb 3
import pandas as pd
import os
import nbdev

# %% ../nbs/02_strategies.ipynb 4
base_path = nbdev.config.get_config().lib_path

# %% ../nbs/02_strategies.ipynb 5
processed_data_dir = base_path / "../Data/Bhavcopy/Processed/"

# Get Nifty500 list
csv_path = base_path / "../Data/Misc/ind_nifty500list.csv"
df500 = pd.read_csv(csv_path).Symbol.to_list()

# %% ../nbs/02_strategies.ipynb 7
def check_directional_crossover(df, col1, col2, days_lookback=7):
    days_lookback = min(days_lookback+1, df.shape[0])
    for d in range(1, days_lookback):
        
        # print(f"Checking for {df.DATE.iloc[-d]}: {df[col1].iloc[-d]}, {df[col2].iloc[-d]}")
        if df[col1].iloc[-d] > df[col2].iloc[-d] and df[col1].iloc[-d-1] < df[col2].iloc[-d-1]:
            # print(f"{col1} crossed over {col2} on {df.DATE.iloc[-d]} : {d} days ago")
            return d
    return 0

# %% ../nbs/02_strategies.ipynb 8
def get_symbol_data(symbol):
    file_path = base_path / processed_data_dir / f"{symbol}.csv"
    if os.path.exists(file_path):
        # print(f"File exists: {file_path}")
        return pd.read_csv(file_path, parse_dates=["DATE"]).assign(DATE = lambda x: x.DATE.dt.strftime("%d %b %Y"))
    else:
        # print(f"File does not exist: {file_path}")
        return None
    

# %% ../nbs/02_strategies.ipynb 9
def check_close_under_falling_20(df, d, days_lookback=10):
    df = df.iloc[-d-days_lookback:-d]
    # print(df.DATE.iloc[0], df.DATE.iloc[-1])
    # df.plot(x="DATE", y=["CLOSE", "SMA_20_C"], figsize=(15, 5))
    # df.plot(x="DATE", y=["CLOSE", "SMA_20_C", "SMA_20_H"], figsize=(15, 5))
    # print(df.SMA_20_C.is_monotonic_decreasing, df.SMA_20_H.is_monotonic_decreasing)
    return all(
        [
            any([df.SMA_20_C.is_monotonic_decreasing,
                 df.SMA_20_H.is_monotonic_decreasing,
                 df.SMA_44_C.is_monotonic_decreasing,
              ]),
            any([
                all(df.CLOSE < df.SMA_20_H),
                # all(df.CLOSE < df.SMA_20_C)
            ]),
            # all(df.SMA_200_C < df.SMA_20_C)
         ])
    
# check_close_under_20(df, 15, 18)

# %% ../nbs/02_strategies.ipynb 10
def check_close_above_20(df, d, days_lookfwd=3):
    df = df.iloc[-d+1:].head(days_lookfwd)
    # print(df)
    # print(df.DATE.iloc[0], df.DATE.iloc[-1])
    # df.plot(x="DATE", y=["CLOSE", "SMA_20_C"], figsize=(15, 5))
    return all(df.CLOSE > df.SMA_20_C) #df.SMA_20_C.is_monotonic_increasing and

# %% ../nbs/02_strategies.ipynb 11
def check_20_200_breakout(df, days_lookback=5):
    found = False
    col1 = "CLOSE"
    col2 = "SMA_20_C"
    col3 = "SMA_200_C"
    col4 = "SMA_20_H"
    # df = df[:-45]
    
    # Check for double crossover on SMA20 and SMA200 within a 3 day period
    dc20 = check_directional_crossover(df, col1, col2, days_lookback=days_lookback)
    if all([dc20 > 0,
            check_close_under_falling_20(df, dc20, days_lookback=30),
            check_close_above_20(df, dc20)
            ]):
        found = True
        dc200 = check_directional_crossover(df, col1, col3, days_lookback=days_lookback)
        # print(dc20, dc200)
        
        if all([dc200 > 0,
                abs(dc20-dc200) < 3
                ]):
            print(f"{df.SYMBOL.iloc[0]} -> Double crossover on {df.DATE.iloc[-dc20]} : {dc20} days ago, with {df.iloc[-dc20].CDL_COLOR} candle")
        else:
            print(f"{df.SYMBOL.iloc[0]} -> SMA20 crossover on {df.DATE.iloc[-dc20]} : {dc20} days ago, with {df.iloc[-dc20].CDL_COLOR} candle")
            if dc200:
                print(f"{df.SYMBOL.iloc[0]} -> SMA 200 crossover: {df.DATE.iloc[-dc200]} : {dc200} days ago, with {df.iloc[-dc200].CDL_COLOR} candle")
    return found

# %% ../nbs/02_strategies.ipynb 12
def check_single_candle_span(df, col_list=["SMA_20_C","SMA_200_C"], days_lookback=2):
    days_lookback = min(days_lookback+1, df.shape[0])
    for d in range(1, days_lookback):
        conditions = []
        for col in col_list:
            conditions.append(df.LOW.iloc[-d] <= df[col].iloc[-d] <= df.HIGH.iloc[-d])
        if all(conditions):
            print(f"{df.SYMBOL.iloc[0]} -> Single candle span on {df.DATE.iloc[-d]} : {d} days ago with {df.iloc[-d].CDL_COLOR} candle")
            return d
    return 0

# %% ../nbs/02_strategies.ipynb 17
def check_historical_minmax(df, min_steps_back = 30, mode=None):
    
    if mode is None or mode=='all':
        mode = ["min", "max"]

    if "DATE" not in df.columns:
        df["DATE"] = df.index
    
    max_steps = len(df)
    if max_steps > min_steps_back:
        if "max" in mode or mode == "max":
            # Search for historical high
            last_is_max = True
            steps_back = 1
            while last_is_max:
                steps_back += 1
                if steps_back > max_steps:
                    print(f"{df.SYMBOL.iloc[-1]}: ALL TIME HIGH on {df.DATE.iloc[-1].date()} closed at {df.CLOSE.iloc[-1]}")
                    return
                last_is_max = df.CLOSE.iloc[-1] >= df.HIGH.iloc[-steps_back]
                
            if steps_back >= min_steps_back:
                print(f"{df.SYMBOL.iloc[-1]} CLOSE -> {df.CLOSE.iloc[-1]} : New high of {steps_back} sessions, since HIGH of {df.HIGH.iloc[-steps_back]} on {df.DATE.iloc[-steps_back].date()}")
            
        if "min" in mode or mode == "min":
            # Search for historical low
            last_is_min = True
            steps_back = 1
            while last_is_min:
                steps_back += 1
                if steps_back > max_steps:
                    print(f"{df.SYMBOL.iloc[-1]}: ALL TIME LOW on {df.DATE.iloc[-1].date()} closed at {df.CLOSE.iloc[-1]}")
                    return
                last_is_min = df.CLOSE.iloc[-1] <= df.LOW.iloc[-steps_back]
            
            if steps_back >= min_steps_back:
                print(f"{df.SYMBOL.iloc[-1]} CLOSE -> {df.CLOSE.iloc[-1]} : New low of {steps_back} sessions, since LOW of {df.LOW.iloc[-steps_back]} on {df.DATE.iloc[-steps_back].date()}")
